import {
	SerializedType,
	TsonNonce,
	TsonType,
	TsonTypeTesterCustom,
} from "../sync/syncTypes.js";
import { TsonGuard } from "../tsonAssert.js";
import {
	TsonAsyncUnfolderFactory,
	createTsonAsyncUnfoldFn,
} from "./createUnfoldAsyncFn.js";

export interface TsonAsyncChunk<T = unknown> {
	chunk: T;
	key?: null | number | string | undefined;
}

export interface TsonAsyncMarshaller<
	TValue,
	TSerializedType extends SerializedType,
> {
	async: true;
	fold: (
		iter: AsyncGenerator<
			TsonAsyncChunk<TSerializedType>,
			// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
			number | undefined | void,
			undefined
		>,
	) => Promise<Awaited<TValue>>;
	key: string;
	unfold: ReturnType<
		typeof createTsonAsyncUnfoldFn<TsonAsyncUnfolderFactory<TValue>>
	>;
}

export type TsonAsyncType<
	/**
	 * The type of the value
	 */
	TValue,
	/**
	 * JSON-serializable value how it's stored after it's serialized
	 */
	TSerializedType extends SerializedType,
> = TsonTypeTesterCustom & TsonAsyncMarshaller<TValue, TSerializedType>;


export interface TsonAsyncOptions {
	/**
	 * A list of guards to apply to every value
	 */
	guards?: TsonGuard<any>[];
	/**
	 * The nonce function every time we start serializing a new object
	 * Should return a unique value every time it's called
	 * @default `${crypto.randomUUID} if available, otherwise a random string generated by Math.random`
	 */
	nonce?: () => string;
	/**
	 * The list of types to use
	 */
	types: (TsonAsyncType<any, any> | TsonType<any, any>)[];
}

export const ChunkTypes = {
	BODY: "BODY",
	ERROR: "ERROR",
	HEAD: "HEAD",
	LEAF: "LEAF",
	REFERENCE: "REFERENCE",
	TAIL: "TAIL",
} as const;

export type ChunkTypes = {
	[key in keyof typeof ChunkTypes]: (typeof ChunkTypes)[key];
};

export const TsonStatus = {
	//MULTI_STATUS: 207,
	ERROR: 500,
	INCOMPLETE: 203,
	OK: 200,
} as const;

export type TsonStatus = {
	[key in keyof typeof TsonStatus]: (typeof TsonStatus)[key];
};

export type TsonAsyncTupleHeader = [
	Id: `${TsonNonce}${number}`,
	ParentId: `${TsonNonce}${"" | number}`,
	Key?: null | number | string | undefined,
];

export type TsonAsyncLeafTuple = [
	ChunkType: ChunkTypes["LEAF"],
	Header: TsonAsyncTupleHeader,
	Value: unknown,
	TypeHandlerKey?: string | undefined,
];

export type TsonAsyncBodyTuple = [
	ChunkType: ChunkTypes["BODY"],
	Header: TsonAsyncTupleHeader,
	Head: TsonAsyncHeadTuple,
	TypeHandlerKey?: string | undefined,
];

export type TsonAsyncHeadTuple = [
	ChunkType: ChunkTypes["HEAD"],
	Header: TsonAsyncTupleHeader,
	TypeHandlerKey?: string | undefined,
];

export type TsonAsyncReferenceTuple = [
	ChunkType: ChunkTypes["REFERENCE"],
	Header: TsonAsyncTupleHeader,
	OriginalNodeId: `${TsonNonce}${number}`,
];

export type TsonAsyncErrorTuple = [
	ChunkType: ChunkTypes["ERROR"],
	Header: TsonAsyncTupleHeader,
	Error: unknown,
];

export type TsonAsyncTailTuple = [
	ChunkType: ChunkTypes["TAIL"],
	Header: [
		Id: TsonAsyncTupleHeader[0],
		ParentId: TsonAsyncTupleHeader[1],
		Key?: null | undefined,
	],
	StatusCode: number,
];

export type TsonAsyncTuple =
	| TsonAsyncBodyTuple
	| TsonAsyncErrorTuple
	| TsonAsyncHeadTuple
	| TsonAsyncLeafTuple
	| TsonAsyncReferenceTuple
	| TsonAsyncTailTuple;

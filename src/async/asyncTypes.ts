import { TsonType } from "../types.js";
import { TsonBranded, TsonTypeTesterCustom } from "../types.js";
import { serialized } from "../types.js";

export type TsonAsyncStringifierIterator<TValue> = AsyncIterable<string> & {
	[serialized]: TValue;
};

export type TsonAsyncStringifier = <TValue>(
	value: TValue,
	space?: number,
) => TsonAsyncStringifierIterator<TValue>;
export type TsonAsyncIndex = TsonBranded<number, "AsyncRegistered">;
export interface TsonTransformerSerializeDeserializeAsync<TValue> {
	async: true;
	/**
	 * From JSON-serializable value
	 */
	deserialize: (
		v: TsonAsyncIndex,
		register: (index: TsonAsyncIndex) => Promise<TValue>,
	) => TValue;

	/**
	 * The key to use when serialized
	 */
	key: string;
	/**
	 * JSON-serializable value
	 */
	serialize: (
		v: TValue,
		register: (thing: TValue) => TsonAsyncIndex,
	) => TsonAsyncIndex;
}

export interface TsonAsyncType<TValue>
	extends TsonTransformerSerializeDeserializeAsync<TValue>,
		TsonTypeTesterCustom {}
export interface TsonAsyncOptions {
	/**
	 * The nonce function every time we start serializing a new object
	 * Should return a unique value every time it's called
	 * @default `${crypto.randomUUID} if available, otherwise a random string generated by Math.random`
	 */
	nonce?: () => number | string;
	/**
	 * The list of types to use
	 */
	types: (TsonAsyncType<any> | TsonType<any, any> | TsonType<any, never>)[];
}
